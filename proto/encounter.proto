syntax = "proto3";

package simulate;

import "proto/actor.proto";

// TODO(mrdmnd): make event timing probabilistic so we don't overfit?
// TODO(mrdmnd): make event occurrence probabilistic (maybe X doesn't happen?)
message ActorSpawnEvent {
  Actor actor = 1;
  int32 duration = 2; // If -1, actor despawns when HP is zero.
}

message ActorInvulnEvent {
  Actor actor = 1;
  int32 duration = 2; // Number of timesteps that this actor is invulnerable.
}

// Logically, this is just a constraint meant to keep you casting only instants.
message MovementEvent {
  int32 duration = 1; // Number of timesteps that we are forced to move for.
}

// Logically, this is just a constraint meant to keep you from casting anything.
message StunEvent {
  int32 duration = 1; // Number of timesteps that we are unable to act for.
}

message TakeDamageEvent {
  int32 damage_amount = 1; // Amount of damage the boss deals to us.
}

// TODO(mrdmnd)
// This is a "fixed" lust trigger, if you know exactly when you're going to pop
// it. There's also a "bloodlust_check" that happens every timeframe in the sim
// which checks if
// a) bloodlust is available (not exhausted) and
// b) bloodlust_percent is reached or time_to_die is less than lust duration.
message BloodlustEvent {
  int32 duration = 1;          // How long lust lasts for.
  double haste_percentage = 1; // How much haste we get.
}

message PrepotEvent {
  int32 potion_id = 1; // Which potion was used
  int32 duration = 2;  // How long it lasts for
}

message EncounterEvent {
  int32 timestamp = 1; // -1 means event happens before fight starts.
  oneof event {
    ActorSpawnEvent spawn = 2;
    ActorInvulnEvent invuln = 3;
    MovementEvent movement = 4;
    StunEvent stun = 5;
    TakeDamageEvent damage = 6;
    BloodlustEvent lust = 7;
    PrepotEvent prepot = 8;
  }
}

message EncounterConfig {
  string name = 1; // Something like "Patchwork" or "Helter Skelter"
  repeated EncounterEvent events = 3;
}
