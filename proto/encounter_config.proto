syntax = "proto3";

package simulatorproto;

enum EnemyType {
  UNUSED_ENEMYTYPE = 0;
  BOSS = 1;
  PRIORITY_ADD = 2;
  ADD = 3;
}

// This is a bit nuanced. A lot of classes need to know when they hit execute
// range. We can make a few assumptions about how the health of our target
// declines over time, but the idea here is to provide a user-defined way to
// specify how health declines over time. You want this to model the actual
// boss health loss function. We provide four: "UNIFORM", "BURST", "EXECUTE",
// "BURST_AND_EXECUTE". UNIFORM sets these values equal to what you'd see from
// uniform raid DPS. BURST assumes you're going to hit the boss extra hard at
// the beginning. EXECUTE assumes you're going to hit the boss extra hard at
// the end. BURST_AND_EXECUTE assumes both.
enum HealthEstimator {
  UNIFORM = 0;
  BURST = 1;
  EXECUTE = 2;
  BURST_AND_EXECUTE = 3;
}

message Enemy {
  int32 id = 1;
  string name = 2;
  EnemyType type = 3;
  HealthEstimator health_estimator = 4;
}

// TODO(mrdmnd): make event timing probabilistic so we don't overfit?
// TODO(mrdmnd): make event occurrence probabilistic (maybe X doesn't happen?)
message EnemySpawnEvent {
  Enemy enemy = 1;
}

message EnemyDespawnEvent {
  int32 enemy_id = 1;
}

message EnemyInvulnEvent {
  Enemy enemy = 1;
  int32 duration = 2;  // Number of timesteps that this actor is invulnerable.
}

// Logically, this is just a constraint meant to keep you casting only instants.
message MovementEvent {
  int32 duration = 1;  // Number of timesteps that we are forced to move for.
}

// Logically, this is just a constraint meant to keep you from casting anything.
message StunEvent {
  int32 duration = 1;  // Number of timesteps that we are unable to act for.
}

message TakeDamageEvent {
  int32 damage_amount = 1;  // Amount of damage the boss deals to us.
}

// This is a "fixed" lust trigger, where you know when you're going to pop it.
// There's also a "bloodlust_check" that happens every timeframe in the sim
// which checks if a) bloodlust is available (not exhausted), and
// b) bloodlust_percent is reached or time_to_die is less than lust duration.
message BloodlustEvent {
  double haste_percentage = 1;  // How much haste we get (drums give less).
}

message EncounterEvent {
  int32 timestamp = 1;  //
  oneof event {
    EnemySpawnEvent spawn = 2;
    EnemyInvulnEvent invuln = 3;
    MovementEvent movement = 4;
    StunEvent stun = 5;
    TakeDamageEvent damage = 6;
    BloodlustEvent lust = 7;
    EnemyDespawnEvent despawn = 8;
  }
}

// Top level fight configuration.
message EncounterConfig {
  // Something descriptive and human readable, like "Patchwork"
  string name = 1;

  // Each fight lasts between min_tim_millis and max_time_millis, selected
  // uniformly at random.
  int32 min_time_millis = 2;

  int32 max_time_millis = 3;

  // A sorted sequence of encounter events.
  repeated EncounterEvent events = 4;
}
