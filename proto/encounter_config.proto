syntax = "proto3";

package simulate;

// This is a bit nuanced. A lot of classes need to know when they hit execute
// range. We can make a few assumptions about how the health of our target
// declines over time, but the idea here is to provide a user-defined way to
// specify how health declines over time. You want this to model the actual
// boss health loss function. We provide four: "UNIFORM", "BURST", "EXECUTE",
// "BURST_AND_EXECUTE". UNIFORM sets these values equal to what you'd see from
// uniform raid DPS. BURST assumes you're going to hit the boss extra hard at
// the beginning. EXECUTE assumes you're going to hit the boss extra hard at
// the end. BURST_AND_EXECUTE assumes both.
enum HealthEstimator {
  UNIFORM = 0;
  BURST = 1;
  EXECUTE = 2;
  BURST_AND_EXECUTE = 3;
}

// BOSS type enemies have all statistics turned on, and use the HealthEstimator
// set in the EncounterConfig proto at the top level. PRIORITY_ADD type
// enemies have fewer statistics collected, and use the BURST health estimator.
// ADD type enemies have minimal statistics collected, and follow the UNIFORM
// health estimator. We don't collect detailed statistics on ADD type enemies,
// and they follow the UNIFORM health estimator.
enum EnemyType {
  UNUSED_ENEMYTYPE = 0;
  BOSS = 1;
  PRIORITY_ADD = 2;
  ADD = 3;
}

message Enemy {
  int32 id = 1;
  string name = 2;
  EnemyType type = 3;
}

// TODO(mrdmnd): make event timing probabilistic so we don't overfit?
// TODO(mrdmnd): make event occurrence probabilistic (maybe X doesn't happen?)
message EnemySpawnEvent {
  Enemy enemy = 1;
}

message EnemyInvulnEvent {
  Enemy enemy = 1;
  int32 duration = 2;  // Number of timesteps that this actor is invulnerable.
}

// Logically, this is just a constraint meant to keep you casting only instants.
message MovementEvent {
  int32 duration = 1;  // Number of timesteps that we are forced to move for.
}

// Logically, this is just a constraint meant to keep you from casting anything.
message StunEvent {
  int32 duration = 1;  // Number of timesteps that we are unable to act for.
}

message TakeDamageEvent {
  int32 damage_amount = 1;  // Amount of damage the boss deals to us.
}

// This is a "fixed" lust trigger, where you know when you're going to pop it.
// There's also a "bloodlust_check" that happens every timeframe in the sim
// which checks if a) bloodlust is available (not exhausted), and
// b) bloodlust_percent is reached or time_to_die is less than lust duration.
message BloodlustEvent {
  double haste_percentage = 1;  // How much haste we get (drums give less).
}

message EncounterEvent {
  int32 timestamp = 1;  // -1 means event happens before fight starts.
  oneof event {
    EnemySpawnEvent spawn = 2;
    EnemyInvulnEvent invuln = 3;
    MovementEvent movement = 4;
    StunEvent stun = 5;
    TakeDamageEvent damage = 6;
    BloodlustEvent lust = 7;
  }
}

// Top level fight configuration.
message EncounterConfig {
  // Something descriptive and human readable, like "Patchwork"
  string name = 1;

  // The health_estimator to use for all BOSS enemies.
  HealthEstimator health_estimator = 2;

  // We attack for time_target +/- time_variance.
  // Reasonable default: 5 minutes, or 300s (300,000 ms)
  int32 time_target = 3;

  // We want combat to run about as long as the encounter says, but not exactly.
  // Reasonable default: 0.10, or 10%.
  double time_variance = 4;

  // A sorted sequence of encounter events.
  repeated EncounterEvent events = 5;
}
